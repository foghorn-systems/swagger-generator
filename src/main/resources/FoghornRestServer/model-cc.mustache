
#include <sstream>

{{#models}}
{{#model}}
#include <foghorn/em/api/rest/generated/model/{{classFilename}}.h>
{{^validatorClass}}
{{#validators}}
#include <foghorn/em/api/rest/generated/model/{{classname}}{{validatorClass}}.h>
{{/validators}}
{{/validatorClass}}
{{/model}}
{{/models}}
{{#imports}}
#include <foghorn/em/api/rest/generated/model/{{import}}.h>
{{/imports}}
#include <foghorn/io/txt/in_strm.inl>
#include <foghorn/io/txt/out_strm.inl>
#include <foghorn/wire/json.inl>

namespace foghorn {
namespace em {

using Json = wire::json_t;

{{#models}}
{{#model}}
// --------------------------------------------------
// {{classname}}
// --------------------------------------------------

{{classname}}::{{classname}}() { {{#hasBarePtrs}}nullPtrs(); {{/hasBarePtrs}}clear(); }
{{classname}}::{{classname}}(const {{classname}}& that) { {{#hasBarePtrs}}nullPtrs(); {{/hasBarePtrs}}copyFrom(that); }
{{classname}}::{{classname}}(const Json& json) { {{#hasBarePtrs}}nullPtrs(); {{/hasBarePtrs}}copyFrom(json); }
{{classname}}& {{classname}}::operator= (const {{classname}}& that) { copyFrom(that); return *this; }
{{classname}}::~{{classname}}() { clear(); }
{{#hasBarePtrs}}

void {{classname}}::nullPtrs() {
   {{#vars}}
   {{^isContainer}}
   {{#isRef}}
   {{name}} = nullptr;
   {{/isRef}}
   {{/isContainer}}
   {{/vars}}
}
{{/hasBarePtrs}}

// --------------------------------------------------
// clear
// --------------------------------------------------

void {{classname}}::clear() {
   {{#vars}}
   {{#isContainer}}
   {{#isRef}}
   { for (unsigned int i = 0; i < {{name}}.size(); i++) delete {{name}}[i]; }
   {{/isRef}}
   {{name}}.clear();
   {{/isContainer}}
   {{^isContainer}}
   {{#isJson}}
   {{name}} = Json {};
   {{/isJson}}
   {{^isJson}}
   {{#isRef}}
   if ({{name}} != nullptr) {
      delete {{name}};
      {{name}} = nullptr;
   }
   {{/isRef}}
   {{^isRef}}
   {{name}} = {{{defaultValue}}};
   {{/isRef}}
   {{/isJson}}
   {{/isContainer}}
   {{/vars}}
}

// --------------------------------------------------
// copyFrom or mergeFrom another {{classname}}
// --------------------------------------------------

void {{classname}}::copyFrom(const {{classname}}& that) {
   clear();
   mergeFrom(that);
}

void {{classname}}::mergeFrom(const {{classname}}& that) {
   {{#vars}}

   // {{name}}
   if (that.{{tester}}()) {
      {{#isContainer}}
      for (unsigned int i = 0; i < that.{{name}}.size(); i++) {
         {{#isRef}}
         {{name}}.push_back(new {{datatype}}(*(that.{{name}}[i]));
         {{/isRef}}
         {{^isRef}}
         {{name}}.push_back(that.{{name}}[i]);
         {{/isRef}}
      }
      {{/isContainer}}
      {{^isContainer}}
      {{#isRef}}
      if ({{name}} == nullptr) {
         {{name}} = new {{datatype}}(*(that.{{name}}));
      } else {
         {{name}}->copyFrom(*(that.{{name}}));
      }
      {{/isRef}}
      {{^isRef}}
      {{name}} = that.{{name}};
      {{/isRef}}
      {{/isContainer}}
   }
   {{/vars}}
}

// --------------------------------------------------
// copyFrom or mergeFrom Json
// --------------------------------------------------

void {{classname}}::copyFrom(const Json& j) {
   clear();
   mergeFrom(j);
}

void {{classname}}::mergeFrom(const Json& j) {
   if (j.get_kind() != Json::object) {
      throw std::runtime_error("{{classname}} body was not an object");
   }
   const Json::object_t& jobj = j.as<Json::object_t>();
   {{#vars}}

   // {{name}}
   { auto iterator = jobj.find("{{name}}");
     if (iterator != jobj.end()) {
	const Json& json = iterator->second;
	{{#isContainer}}
        if (json.get_kind() != Json::array) {
           throw std::runtime_error("{{classname}} property {{name}} was not an array");
        }
	const Json::array_t& array = json.as<Json::array_t>();
        for (unsigned int i = 0; i < array.size(); i++) {
           const Json& itemJson = array[i];
           {{#items}}
           {{#isJson}}
	   {{name}}.push_back(itemJson);
           {{/isJson}}
           {{^isJson}}
           {{#isRef}}
	   {{name}}.push_back(new {{datatype}}(itemJson));
           {{/isRef}}
           {{^isRef}}
           if (itemJson.get_kind() != Json::{{jsonType}}) {
              throw std::runtime_error("{{classname}} property {{name}} item was not {{jsonType}}");
           }
           {{name}}.push_back(itemJson.as<Json::{{jsonType}}_t>());
           {{/isRef}}
           {{/isJson}}
           {{/items}}
	}
	{{/isContainer}}
	{{^isContainer}}
        {{#isJson}}
	{{name}} = json;
        {{/isJson}}
        {{^isJson}}
        {{#isRef}}
	if ({{name}} == nullptr) {
           {{name}} = new {{datatype}}(json);
        } else {
           {{name}}->copyFrom(json);
        }
        {{/isRef}}
        {{^isRef}}
        if (json.get_kind() != Json::{{jsonType}}) {
           throw std::runtime_error("{{classname}} property {{name}} was not {{jsonType}}");
        }
        {{name}} = json.as<Json::{{jsonType}}_t>();
        {{/isRef}}
        {{/isJson}}
	{{/isContainer}}
     }
   }
   {{/vars}}
}

// --------------------------------------------------
// toJson or string
// --------------------------------------------------

std::string {{classname}}::toString() const {
   return io::txt::to_string(toJson());
}

Json {{classname}}::toJson() const {
   Json::object_t info;
   {{#vars}}

   // {{name}}
   if ({{tester}}()) {
      {{#isContainer}}
      Json::array_t arr;
      for (unsigned int i = 0; i < {{name}}.size(); i++) {
         {{#items}}
         {{fieldType}} item = {{name}}[i];
         {{#isJson}}
	 arr.push_back(item);
         {{/isJson}}
         {{^isJson}}
         {{#isRef}}
         arr.push_back(item->toJson());
         {{/isRef}}
         {{^isRef}}
         {{#isString}}
         arr.push_back(Json { std::move(item) });
         {{/isString}}
         {{^isString}}
         arr.push_back(Json { item });
         {{/isString}}
         {{/isRef}}
         {{/isJson}}
         {{/items}}
      }
      info["{{name}}"] = Json{ std::move(arr) };
      {{/isContainer}}
      {{^isContainer}}
      {{#isJson}}
      info["{{name}}"] = {{name}};
      {{/isJson}}
      {{^isJson}}
      {{#isRef}}
      info["{{name}}"] = {{name}}->toJson();
      {{/isRef}}
      {{^isRef}}
      {{#isString}}
      info["{{name}}"] = Json{ std::string({{name}}) };
      {{/isString}}
      {{^isString}}
      info["{{name}}"] = Json{ {{name}} };
      {{/isString}}
      {{/isRef}}
      {{/isJson}}
      {{/isContainer}}
   }
   {{/vars}}

   return Json{ std::move(info) };
}

void {{classname}}::throwIfMissingRequiredFields() const {
  {{#vars}}
  {{#required}}
  if (!{{tester}}()) {
    throw std::runtime_error("{{classname}} missing required property \"{{name}}\"");
  }
  {{/required}}
  {{/vars}}
}
{{^validatorClass}}

// --------------------------------------------------
// validators
// --------------------------------------------------
{{#validators}}

void {{classname}}::from{{validatorClass}}(const {{classname}}{{validatorClass}}& {{validatorParam}}) {
   {{#validatorVars}}
   {{setter}}({{validatorParam}}.{{getter}}());
   {{/validatorVars}}
   {{^validatorVars}}
   // No fields to set
   {{/validatorVars}}
}
{{/validators}}
{{/validatorClass}}

// --------------------------------------------------
// setters/getters/testers
// --------------------------------------------------
{{#vars}}

// {{name}}
bool {{classname}}::{{tester}}() const {
   {{#isContainer}}
   return !{{name}}.empty();
   {{/isContainer}}
   {{^isContainer}}
   {{#isJson}}
   return {{name}}.get_kind() != Json::null;
   {{/isJson}}
   {{^isJson}}
   {{#isRef}}
   return {{name}} != nullptr;
   {{/isRef}}
   {{^isRef}}
   {{#isString}}
   return {{name}}.compare({{{defaultValue}}});
   {{/isString}}
   {{^isString}}
   return {{name}} != {{{defaultValue}}};
   {{/isString}}
   {{/isRef}}
   {{/isJson}}
   {{/isContainer}}
}
{{{datatype}}} {{classname}}::{{getter}}() const {
   {{#isRef}}
   {{^isContainer}}
   return ({{name}} != nullptr) ? *{{name}} : {{datatype}}();
   {{/isContainer}}
   {{#isContainer}}
   {{datatype}} result;
   for (unsigned int i = 0; i < {{name}}.size(); i++) {
      result.push_back(*({{name}}[i]));
   }
   return result;
   {{/isContainer}}
   {{/isRef}}
   {{^isRef}}
   return {{name}};
   {{/isRef}}
}
{{classname}}& {{classname}}::{{setter}}({{{paramType}}} {{name}}_) {
   {{#isRef}}
   {{^isContainer}}
   if ({{name}} == nullptr) {
      {{name}} = new {{{datatype}}}({{name}}_);
   } else {
      {{name}}->copyFrom({{name}}_);
   }
   {{/isContainer}}
   {{#isContainer}}
   { for (unsigned int i = 0; i < {{name}}.size(); i++) delete {{name}}[i]; }
   {{name}}.clear();
   for (unsigned int i = 0; i < {{name}}_.size(); i++) {
      {{#items}}
      {{name}}.push_back(new {{datatype}}({{name}}_[i]));
      {{/items}}
   }
   {{/isContainer}}
   {{/isRef}}
   {{^isRef}}
   {{name}} = {{name}}_;
   {{/isRef}}
   return *this;
}
{{/vars}}

{{/model}}
{{/models}}
}  // em namespace
}  // foghorn namespace


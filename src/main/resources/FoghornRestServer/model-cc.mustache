
#include <sstream>

{{#models}}
{{#model}}
#include <foghorn/em/api/rest/generated/model/{{classFilename}}.h>
{{^validatorClass}}
{{#validators}}
#include <foghorn/em/api/rest/generated/model/{{classname}}{{validatorClass}}.h>
{{/validators}}
{{/validatorClass}}
{{/model}}
{{/models}}
{{#imports}}
#include <foghorn/em/api/rest/generated/model/{{import}}.h>
{{/imports}}
#include <foghorn/io/txt/in_strm.inl>
#include <foghorn/io/txt/out_strm.inl>
#include <foghorn/wire/json.inl>
#include <foghorn/wire/rest.inl>

namespace foghorn {
namespace em {

namespace rest = foghorn::wire::rest;
using http_status_t = wire::rest::http_status_t;
using Json = wire::json_t;

{{#models}}
{{#model}}
// --------------------------------------------------
// {{classname}}
// --------------------------------------------------

{{classname}}::{{classname}}() { clear(); }
{{classname}}::~{{classname}}() { clear(); }
{{classname}}::{{classname}}(const {{classname}}& that) { copyFrom(that); }
{{classname}}::{{classname}}(const Json& json) { copyFrom(json); }
{{classname}}& {{classname}}::operator= (const {{classname}}& that) { copyFrom(that); }

// --------------------------------------------------
// clear
// --------------------------------------------------

void {{classname}}::clear() {
   {{#vars}}
   {{#isContainer}}
   {{#isRef}}
   { for (unsigned int i = 0; i < {{name}}.size(); i++) delete {{name}}[i]; }
   {{/isRef}}
   {{name}}.clear();
   {{/isContainer}}
   {{^isContainer}}
   {{#isJson}}
   {{name}} = Json {};
   {{/isJson}}
   {{^isJson}}
   {{#isRef}}
   if ({{name}} != nullptr) {
      delete {{name}};
      {{name}} = nullptr;
   }
   {{/isRef}}
   {{^isRef}}
   {{name}} = {{{defaultValue}}};
   {{/isRef}}
   {{/isJson}}
   {{/isContainer}}
   {{/vars}}
}

// --------------------------------------------------
// copyFrom or mergeFrom another {{classname}}
// --------------------------------------------------

void {{classname}}::copyFrom(const {{classname}}& that) {
   clear();
   mergeFrom(that);
}

void {{classname}}::mergeFrom(const {{classname}}& that) {
   {{#vars}}
   {{#isContainer}}
   for (unsigned int i = 0; i < that.{{name}}.size(); i++) {
      {{#isRef}}
      {{name}}.push_back(new {{datatype}}(*(that.{{name}}[i]));
      {{/isRef}}
      {{^isRef}}
      {{name}}.push_back(that.{{name}}[i]);
      {{/isRef}}
   }
   {{/isContainer}}
   {{^isContainer}}
   {{#isRef}}
   if (that.{{name}} != nullptr) {
      {{{paramType}}} other = *(that.{{name}});
      if ({{name}} == nullptr) {
         {{name}} = new {{datatype}}(other);
      } else {
         {{name}}->copyFrom(other);
      }
   }
   {{/isRef}}
   {{^isRef}}
   {{name}} = that.{{name}};
   {{/isRef}}
   {{/isContainer}}
   {{/vars}}
}

// --------------------------------------------------
// copyFrom or mergeFrom Json
// --------------------------------------------------

void {{classname}}::copyFrom(const Json& j) {
   clear();
   mergeFrom(j);
}

void {{classname}}::mergeFrom(const Json& j) {
   if (j.get_kind() != Json::object) {
      throw rest::Error("{{classname}} body was not an object",
         http_status_t::bad_request);
   }
   const Json::object_t& jobj = j.as<Json::object_t>();
   {{#vars}}

   // {{name}}
   { auto iterator = jobj.find("{{name}}");
     if (iterator != jobj.end()) {
	const Json& json = iterator->second;
	{{#isContainer}}
        if (json.get_kind() != Json::array) {
           throw rest::Error("{{classname}} property {{name}} was not an array",
	      http_status_t::bad_request);
        }
	const Json::array_t& array = json.as<Json::array_t>();
        for (unsigned int i = 0; i < array.size(); i++) {
           const Json& itemJson = array[i];
           {{#items}}
           {{#isJson}}
	   {{name}}.push_back(itemJson);
           {{/isJson}}
           {{^isJson}}
           {{#isRef}}
	   {{name}}.push_back(new {{datatype}}(itemJson));
           {{/isRef}}
           {{^isRef}}
           if (itemJson.get_kind() != Json::{{jsonType}}) {
              throw rest::Error("{{classname}} property {{name}} item was not {{jsonType}}",
	         http_status_t::bad_request);
           }
           {{name}}.push_back(itemJson.as<Json::{{jsonType}}_t>());
           {{/isRef}}
           {{/isJson}}
           {{/items}}
	}
	{{/isContainer}}
	{{^isContainer}}
        {{#isJson}}
	{{name}} = json;
        {{/isJson}}
        {{^isJson}}
        {{#isRef}}
	if ({{name}} == nullptr) {
           {{name}} = new {{datatype}}(json);
        } else {
           {{name}}->copyFrom(json);
        }
        {{/isRef}}
        {{^isRef}}
        if (json.get_kind() != Json::{{jsonType}}) {
           throw rest::Error("{{classname}} property {{name}} was not {{jsonType}}",
	      http_status_t::bad_request);
        }
        {{name}} = json.as<Json::{{jsonType}}_t>();
        {{/isRef}}
        {{/isJson}}
	{{/isContainer}}
     }{{#required}} else {
        throw rest::Error("{{classFilename}} missing required property \"{{name}}\"",
	   http_status_t::bad_request);
     }{{/required}}
   }
   {{/vars}}
}

// --------------------------------------------------
// toJson or string
// --------------------------------------------------

std::string {{classname}}::toString() const {
   return io::txt::to_string(toJson());
}

Json {{classname}}::toJson() const {
   Json::object_t info;
   {{#vars}}

   // {{name}}
   {{#isContainer}}
   if (!{{name}}.empty()) {
      Json::array_t arr;
      for (unsigned int i = 0; i < {{name}}.size(); i++) {
         {{#items}}
         {{fieldType}} item = {{name}}[i];
         {{#isJson}}
	 arr.push_back(item);
         {{/isJson}}
         {{^isJson}}
         {{#isRef}}
         arr.push_back(item->toJson());
         {{/isRef}}
         {{^isRef}}
         {{#isString}}
         arr.push_back(Json { std::move(item) });
         {{/isString}}
         {{^isString}}
         arr.push_back(Json { item });
         {{/isString}}
         {{/isRef}}
         {{/isJson}}
         {{/items}}
      }
      info["{{name}}"] = Json{ std::move(arr) };
   }
   {{/isContainer}}
   {{^isContainer}}
   {{#isJson}}
   if ({{name}}.get_kind() != Json::null) {
     info["{{name}}"] = {{name}};
   }
   {{/isJson}}
   {{^isJson}}
   {{#isRef}}
   if ({{name}} != nullptr) {
      info["{{name}}"] = {{name}}->toJson();
   }
   {{/isRef}}
   {{^isRef}}
   {{#isString}}
   if ({{name}}.compare({{{defaultValue}}})) {
      info["{{name}}"] = Json{ std::string({{name}}) };
   }
   {{/isString}}
   {{^isString}}
   if ({{name}} != {{{defaultValue}}}) {
      info["{{name}}"] = Json{ {{name}} };
   }
   {{/isString}}
   {{/isRef}}
   {{/isJson}}
   {{/isContainer}}
   {{/vars}}

   return Json{ std::move(info) };
}
{{^validatorClass}}

// --------------------------------------------------
// validators
// --------------------------------------------------
{{#validators}}

void {{classname}}::from{{validatorClass}}(const {{classname}}{{validatorClass}}& {{validatorParam}}) {
   {{#validatorVars}}
   {{setter}}({{validatorParam}}.{{getter}}());
   {{/validatorVars}}
   {{^validatorVars}}
   // No fields to set
   {{/validatorVars}}
}
{{/validators}}
{{/validatorClass}}

// --------------------------------------------------
// setters/getters
// --------------------------------------------------
{{#vars}}

// {{name}}
{{{datatype}}} {{classname}}::{{getter}}() const {
   {{#isRef}}
   {{^isContainer}}
   return ({{name}} != nullptr) ? *{{name}} : {{datatype}}();
   {{/isContainer}}
   {{#isContainer}}
   {{datatype}} result;
   for (unsigned int i = 0; i < {{name}}.size(); i++) {
      result.push_back(*({{name}}[i]));
   }
   return result;
   {{/isContainer}}
   {{/isRef}}
   {{^isRef}}
   return {{name}};
   {{/isRef}}
}
void {{classname}}::{{setter}}({{{paramType}}} {{name}}_) {
   {{#isRef}}
   {{^isContainer}}
   if ({{name}} == nullptr) {
      {{name}} = new {{{datatype}}}({{name}}_);
   } else {
      {{name}}->copyFrom({{name}}_);
   }
   {{/isContainer}}
   {{#isContainer}}
   { for (unsigned int i = 0; i < {{name}}.size(); i++) delete {{name}}[i]; }
   {{name}}.clear();
   for (unsigned int i = 0; i < {{name}}_.size(); i++) {
      {{#items}}
      {{name}}.push_back(new {{datatype}}({{name}}_[i]));
      {{/items}}
   }
   {{/isContainer}}
   {{/isRef}}
   {{^isRef}}
   {{name}} = {{name}}_;
   {{/isRef}}
}
{{/vars}}

{{#idPrefix}}
// --------------------------------------------------
// IDS
// --------------------------------------------------

// "{{classname}}" has an "id" field, so here's
// a method to generate a sequence of unique ids:
static int {{idPrefix}}_id_count = 1;
std::string {{classname}}::newId() {
   std::ostringstream ss;
   ss << "{{idPrefix}}" << ({{idPrefix}}_id_count++);
   return ss.str();
}

{{/idPrefix}}
{{/model}}
{{/models}}
}  // em namespace
}  // foghorn namespace

